[["index.html", "A Minimal Book Example Chapter 1 About 1.1 Usage 1.2 Render book 1.3 Preview book", " A Minimal Book Example John Doe 2022-07-20 Chapter 1 About This is a sample book written in Markdown. You can use anything that Pandoc’s Markdown supports; for example, a math equation \\(a^2 + b^2 = c^2\\). 1.1 Usage Each bookdown chapter is an .Rmd file, and each .Rmd file can contain one (and only one) chapter. A chapter must start with a first-level heading: # A good chapter, and can contain one (and only one) first-level heading. Use second-level and higher headings within chapters like: ## A short section or ### An even shorter section. The index.Rmd file is required, and is also your first book chapter. It will be the homepage when you render the book. 1.2 Render book You can render the HTML version of this example book without changing anything: Find the Build pane in the RStudio IDE, and Click on Build Book, then select your output format, or select “All formats” if you’d like to use multiple formats from the same book source files. Or build the book from the R console: bookdown::render_book() To render this example to PDF as a bookdown::pdf_book, you’ll need to install XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.org/tinytex/. 1.3 Preview book As you work, you may start a local server to live preview this HTML book. This preview will update as you edit the book when you save individual .Rmd files. You can start the server in a work session by using the RStudio add-in “Preview book”, or from the R console: bookdown::serve_book() "],["hello-bookdown.html", "Chapter 2 Hello bookdown 2.1 A section", " Chapter 2 Hello bookdown All chapters start with a first-level heading followed by your chapter title, like the line above. There should be only one first-level heading (#) per .Rmd file. 2.1 A section All chapter sections start with a second-level (##) or higher heading followed by your section title, like the sections above and below here. You can have as many as you want within a chapter. An unnumbered section Chapters and sections are numbered by default. To un-number a heading, add a {.unnumbered} or the shorter {-} at the end of the heading, like in this section. "],["hello-bookdown-1.html", "Chapter 3 Hello bookdown 3.1 A section", " Chapter 3 Hello bookdown All chapters start with a first-level heading followed by your chapter title, like the line above. There should be only one first-level heading (#) per .Rmd file. 3.1 A section All chapter sections start with a second-level (##) or higher heading followed by your section title, like the sections above and below here. You can have as many as you want within a chapter. An unnumbered section Chapters and sections are numbered by default. To un-number a heading, add a {.unnumbered} or the shorter {-} at the end of the heading, like in this section. "],["hello-bookdown-2.html", "Chapter 4 Hello bookdown 4.1 A section", " Chapter 4 Hello bookdown All chapters start with a first-level heading followed by your chapter title, like the line above. There should be only one first-level heading (#) per .Rmd file. 4.1 A section All chapter sections start with a second-level (##) or higher heading followed by your section title, like the sections above and below here. You can have as many as you want within a chapter. An unnumbered section Chapters and sections are numbered by default. To un-number a heading, add a {.unnumbered} or the shorter {-} at the end of the heading, like in this section. "],["kubernetes-trainingtutorial.html", "Chapter 5 Kubernetes Training/Tutorial 5.1 Pods - TBF 5.2 Kubectl 5.3 Labels, Selectors and Annotations - TBF 5.4 Service Discovery 5.5 Volume &amp; Storage 5.6 Namespaces", " Chapter 5 Kubernetes Training/Tutorial 5.1 Pods - TBF In K8s, a pod is the smallest deployable unit (and not containers | In contrast to K8s, the smallest deployable unit for docker are containers.). Within a pod there is always one main container representing the application (in whatever language written, e.g. JS, Python, Go). Further within a pod, there may or may not be init containers, and/or side containers. Init containers are containers that are executed before the main container. Side containers are containers that support the main containers, e.g. a container that acts as a proxy to your main container. Also within pods there may also be volumes, which enables containers to share data between them. Pod Containers communicate with each other within a pod using localhost and whatever port they expose. The port itself has a unique ip adress. This enables communication between pods via the unique adress. group of one or more Container represents a running process shares Network and Volumes Never Create Pods on its own. Use Controllers instead, e.g. Deployments Ephemeral (not a long lifetime) and disposable 5.1.0.1 Imperative &amp; Declarative Management The imperative approach is good for learning, troubleshooting, and experimenting on the cluster. While the declarative approach is reproducible, which means the same configuration can be applied in different environments (prod/dev). This is best practice to use when building a cluster. This differentiation does not only hold for pods, but for all ressources within a cluster. 5.1.0.1.1 Imperative Management kubectl run &lt;pod-name&gt; --image=&quot;image-name&quot; --port=80 # run following to test your pods # in your browser, go to localhost:8080 kubectl port-forward pod/&lt;pod-name&gt; 8080:80 5.1.0.1.2 Declarative Management / Configuration Declarative configuration is done using a yaml. This works basically on key-value pairs. apiVersion: v1 kind: Pod metadata: name: hello-world labels: name: hello-world spec: # remember: a pod is a selection of one or more containers, # we can also set more containers: - name: hello image: &quot;image-name&quot; # This pod can access only a the amount of ressources specified under limits ressources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; ports: ContainerPorts: 80 Appyl this declarative configuration using the following kubectl command. kubectl apply -f &quot;file-name.yaml&quot; # run following to test your pods # in your browser, go to localhost:8080 kubectl port-forward pod/&lt;pod-name&gt; 8080:80 5.2 Kubectl # run following to test your pods # in your browser, go to localhost:8080 kubectl port-forward pod/&lt;pod-name&gt; 8080:80 # show all pods currently running in the cluster kubectl get pods # delete a pod kubectl delete pods &lt;pod-name&gt; 5.3 Labels, Selectors and Annotations - TBF We have seen labels in the yamls under metadata beforehand. What are they actually doing? Labels are a key-value pair that can be attached to objects such as Pods, Deployments, Replicaset, Services, etc. They are used to organize and select objects. Selectors are used to filter K8s objects based on a set of labels. A selector basically simply uses a boolean language to select pods. The selector matches all or nothing. Everything specified in the selector must be fulfilled in the labels. However, this goes not the other way around. If we have multiple labels and the only one selector, which actually matches one of the labels, the selector will match the object This is seen in below example. # Show all pods including their labels kubectl get pods --show-labels # Show only pods that match the specified selector key-value pairs kubectl get pods --selector=&quot;key=value&quot; kubectl get pods --selector=&quot;key=value,key2=value2&quot; # in short you can also write kubectl get pods -l key=value # or also look for multiple kubectl get pods -l &#39;key in (value1, value2)&#39; Match a replicaset to a Pod. Any Pods has the label app:customer. The replicaset create replicas by selecting only labels matching to app: customer. We can also use multiple labels. Service matches to both pods, blue and green. The Service labels-and-selectors-2 has no endpoints, as it is all or none, and no pod has the label environment=service. apiVersion: v1 kind: Pod metadata: name: blue labels: app: blue annotations: kubernetes.io/change-cause: &quot;seblum/kubernetes:hello-world&quot; spec: containers: - name: blue image: &quot;seblum/kubernetes:blue&quot; resources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; --- apiVersion: v1 kind: Pod metadata: name: green labels: app: blue spec: containers: - name: green image: &quot;seblum/kubernetes:green&quot; resources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; --- apiVersion: v1 kind: Service metadata: name: labels-and-selectors spec: type: NodePort selector: name: blue ports: - port: 80 targetPort: 8080 --- apiVersion: v1 kind: Service metadata: name: labels-and-selectors-2 spec: type: NodePort selector: name: blue environment: service ports: - port: 80 targetPort: 8081 Test it using: # Show all pods including their labels kubectl describe svc labels-and-selectors # Show only pods that match the specified selector key-value pairs kubectl get pods --selector=&quot;key=value&quot; Annotations is an unstructures key value map stored with a resource that may be set by external tools to store and retrieve any metadata. They are not used for queriying purposes. They are used to assist tools and libraries to work with the Kubernetes object. For e.g. to pass configuration around between systems. Send some value that external tools know more perform informed decisions based on the annotiations provided. 5.4 Service Discovery Service Discovery is a mechanism for applications and microservices to locate each other on a network. Actually, we have used Service Discovery already in the previous sections, we just haven’t mentioned it yet. As the name says, Service Discovery happens through services. If a client wants to communicate with the application, we should not use the individual pod ip, because pods are ephemeral. Instead, we should rely on services, because they have a stable IP address. Also, it has a DNS. DNS (Domain Name System) translates domain names to IP addresses so browsers can load internet resources. Service Discovery How does service registration work? When a service is created, it is registered in the service registry with the service name and the service IP. Most clusters use CoreDNS as a service registry. Looking it the cluster, one will see that der is a core-dns service running. If you have a closer look using describe, this service has only one endpoint. Now you know what it is good for. If you want to have an even closer look, you can look on the pods themselves and check the file /etc/resolv.conf. There you find a nameserver where the IP is the one of the core-dns kubectl get pods -n kube-system kubectl get service -n kube-system # command for queriying the dns nslookup &lt;podname&gt; Accessing services from different namespaces. Querying services depends on the namespace you are in. With a service, one gets an associated endpoint with it. The endpoint contains a list of ip adresses to pods which have matched a particular selector, and also which are healthy. If a pod is not healthy, there is no point of a service to loadbalance traffic between those pods. kubectl get endpoints 5.4.0.1 kube-proxy Each node has three components: Kubelet, Container Runtime, Kube Proxy. Kubeproxy is a networkd proxy that runs on each node. Implementing part of the K8s service. It maintains networks rules to allow communication to pods from inside and outside the cluster. Kubeproxy also implements a controller that watches the API server for new services and endpoints. When there is a new service or endpoint, the kubeproxy creates a local IPVS rule that tells the node to intercept traffic destined to the service clusterIP. IPVS (IP virtual server) is built on top of the net filter and implements a transport layer load balancing as part of the linux kernel. It gives the ability to load balance to real service. Kubepory also redirects traffic to pods that match service label selectors. Kubeproy is intercepting all the requests and makes sure that when a request to the cluster ip is sent. using endpoints. Request is sent to the healthy pods behind the endpoints. 5.5 Volume &amp; Storage Since Pods are ephemeral, any data associated is deleted when a pod or container restarts. However, there are times when data wants to be kept, share data between Pods, or persist data to the host file system (disk). The majority of the times, applications are run stateless, meaning we dont want to keep data on the node and store data in a DB. Yet, there are times we want to have access to the file system. When we look at the previous section of the pods. A pod can contain volumes. They are used to store and access data which can be sure or long lived on K8s. Different types of volumes + EmptyDir + HostPath Volume Volume: EmptyDir The volume is initially empty (as the name suggests), and the volume is a temporary directory that shares the pods lifetime. If the pod dies, the contents of the emptyDir are lost. It is also used to share data between containers inside a Pod. apiVersion: apps/v1 kind: Deployment metadata: name: emptydir-volume spec: selector: matchLabels: app: emptydir-volume template: metadata: labels: app: emptydir-volume spec: volumes: # mimic a caching memory type # we can also add a second volume - name: cache # now that we have this temp directory, we can use it in the containers emptyDir: {} containers: - name: container-one image: busybox # image used for testing purposes # since the testing image immediately dies, we want to # execute our own sh command to interact with the volume volumeMounts: # The name must match the name of the volume - name: cache # interal reference of the pod mountPath: /foo command: - &quot;/bin/sh&quot; args: - &quot;-c&quot; - &quot;touch /foo/bar.txt &amp;&amp; sleep 3600&quot; resources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; - name: container-two image: busybox volumeMounts: - name: cache mountPath: /footwo command: - &quot;sleep&quot; - &quot;3600&quot; resources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; if we would create it without the shell commands, the pod will be in a crashloopbackoff. So it is caught in the sleep command. We can check whether the foo/bar.txt is actually created. # get in container kubectl exec -it &lt;emptydir-volume-name&gt; -c container-one -- sh # check whether bar.txt is present ls # going in the second container, there is also a file foo/bar.txt # remember, both containers share the same volume kubectl exec -it &lt;emptydir-volume-name&gt; -c container-two -- sh ls Volume: HostPath Volume type is used when an application need to access the underlying host file system, so the node file system. This can be quite dangerous. If you have the right access, the application can mess up the host. Thus, it is recommended to have it read only. HostPath represents a pre-existing file or directory on the host machine. apiVersion: apps/v1 kind: Deployment metadata: name: hostpath-volume spec: selector: matchLabels: app: hostpath-volume template: metadata: labels: app: hostpath-volume spec: volumes: - name: var-log HostPath: {} path: /var/log containers: - name: container-one image: busybox volumeMounts: - name: var-log mountPath: /var/log command: - &quot;/bin/sh&quot; args: - &quot;-c&quot; - &quot;touch /foo/bar.txt &amp;&amp; sleep 3600&quot; resources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; If you ssh into the node, you see the file /foo/bar.txt Other volume types + awsElasticBlockStore: EBS volumes are persisted and originally unmounted. Read Write one only + Full list can be found here: https://kubernetes.io/docs/concepts/storage/volumes/#volume-types 5.5.0.1 Persistent Volumes Persistent Volumes allow us to store data beyond Pod lifecycle. If a Pod fails, dies or moves to a different node, it does not matter. The data is still intact and will be shared between pods. Persistent Volume types are implemented as plugins (a full list can be found online). Kubernetes supports different persistent volume types, such as: + NFS + Local + Cloud Network storage (AWS EBS, Azure File Storage, Google Persistent Disk) How it works: K8s is running on EKS. We have a AWS EBS. In K8s we have a Container storage interface (CSI). This CSI has to be implemented by the EBS. There is a aws-ebs-plugin, which is implemented by the provider. This gives us a persistent volume. Really, a Persistent Volume is the mapping between the storage provider (EBS) To the kubernetes cluster. If a pod wants to consume storage of a volume, We have to use a persistent volume claim (PVC) Persistent Volume Subsystem All of this is part of a Persistent Volume Subsystem. A Persistent Volume Subsystem provides an API for users and administrators that abstracts details of how storage is provided from how it is consumed. This is done using Persistent Volume and PVC. From a PV, we can configure the storage class. Do we want a fast, slow, or both storage. What are the paramters to configure our storage? PVC is how an enduser (pods) gets access to the persistent volume. Persistent Volume: is a storage resource provisioned by an administrator PVC: is a user’s request for and claim to a persistent volume. Storage Class: describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned. apiVersion: v1 kind: PersistentVolume metadata: name: mypv spec: capacity: storage: &quot;100Mi&quot; volumeMode: Filesystem accessModes: - ReadWriteOnce persistentVolumeReclaimPolicy: Recycle storageClassName: manual hostPath: # this path on node path: &quot;/mnt/data&quot; --- apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mypvc spec: resources: requests: storage: &quot;100Mi&quot; volumeMode: Filesystem storageClassName: &quot;manual&quot; accessModes: - ReadWriteOnce --- apiVersion: apps/v1 kind: Deployment metadata: name: pv-pvc-deployment namespace: engineering spec: selector: matchLabels: app: pv-pvc template: metadata: labels: app: pv-pvc spec: volumes: - name: data # here we define that we want to use the PVC by the name persistentVolumeClaim: claimName: mypvc containers: - name: pv-pvc # default image image: nginx volumeMounts: # now that we have the claim, we have to mount inside the container # is this on pod - mountPath: &quot;/usr/share/nginx/html&quot; # name is equal to the pvc name specified name: data resources: limits: memory: &quot;128Mi&quot; cpu: &quot;500m&quot; ports: - containerPort: 80 --- apiVersion: v1 kind: Service metadata: name: pv-pvc spec: type: LoadBalancer selector: app: pv-pvc ports: - port: 80 targetPort: 80 5.6 Namespaces Namespaces allows us to organize objects in the cluster. Maybe we want to organize by team, department, environment, etc. By default, kubectl interacts with the defaul namespace. default The default namespace for objects with no other namespace kube-system The namespace for objects created by the Kubernetes system kube-public This namespace is created automatically and is readable by all users (including those not authenticated). This namespace is mostly reserved for cluster usage, in case that some resources should be visible and readable publicly throughout the whole cluster. The public aspect of this namespace is only a convention, not a requirement. kube-node-lease This namespace for the lease objects associated with each node which improves the performance of the node heartbeats as the cluster scales. apiVersion: v1 kind: Namespace metadata: name: dev --- apiVersion: v1 kind: Namespace metadata: name: prod --- apiVersion: v1 kind: Namespace metadata: name: monitoring --- apiVersion: v1 kind: Namespace metadata: name: logging "],["blocks.html", "Chapter 6 Blocks 6.1 Equations 6.2 Theorems and proofs 6.3 Callout blocks", " Chapter 6 Blocks 6.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{6.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (6.1). 6.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 6.1. Theorem 6.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 6.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["sharing-your-book.html", "Chapter 7 Sharing your book 7.1 Publishing 7.2 404 pages 7.3 Metadata for sharing", " Chapter 7 Sharing your book 7.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 7.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 7.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["cross.html", "Chapter 8 Cross-references 8.1 Chapters and sub-chapters 8.2 Captioned figures and tables", " Chapter 8 Cross-references Cross-references make it easier for your readers to find and link to elements in your book. 8.1 Chapters and sub-chapters There are two steps to cross-reference any heading: Label the heading: # Hello world {#nice-label}. Leave the label off if you like the automated heading generated based on your heading title: for example, # Hello world = # Hello world {#hello-world}. To label an un-numbered heading, use: # Hello world {-#nice-label} or {# Hello world .unnumbered}. Next, reference the labeled heading anywhere in the text using \\@ref(nice-label); for example, please see Chapter 8. If you prefer text as the link instead of a numbered reference use: any text you want can go here. 8.2 Captioned figures and tables Figures and tables with captions can also be cross-referenced from elsewhere in your book using \\@ref(fig:chunk-label) and \\@ref(tab:chunk-label), respectively. See Figure 8.1. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 8.1: Here is a nice figure! Don’t miss Table 8.1. knitr::kable( head(pressure, 10), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 8.1: Here is a nice table! temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 "],["blocks-1.html", "Chapter 9 Blocks 9.1 Equations 9.2 Theorems and proofs 9.3 Callout blocks", " Chapter 9 Blocks 9.1 Equations Here is an equation. \\[\\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} \\tag{6.1} \\end{equation}\\] You may refer to using \\@ref(eq:binom), like see Equation (6.1). 9.2 Theorems and proofs Labeled theorems can be referenced in text using \\@ref(thm:tri), for example, check out this smart theorem 6.1. Theorem 6.1 For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] Read more here https://bookdown.org/yihui/bookdown/markdown-extensions-by-bookdown.html. 9.3 Callout blocks The R Markdown Cookbook provides more help on how to use custom blocks to design your own callouts: https://bookdown.org/yihui/rmarkdown-cookbook/custom-blocks.html "],["footnotes-and-citations.html", "Chapter 10 Footnotes and citations 10.1 Footnotes 10.2 Citations", " Chapter 10 Footnotes and citations 10.1 Footnotes Footnotes are put inside the square brackets after a caret ^[]. Like this one 1. 10.2 Citations Reference items in your bibliography file(s) using @key. For example, we are using the bookdown package (Xie 2022) (check out the last code chunk in index.Rmd to see how this citation key was added) in this sample book, which was built on top of R Markdown and knitr (Xie 2015) (this citation was added manually in an external file book.bib). Note that the .bib files need to be listed in the index.Rmd with the YAML bibliography key. The RStudio Visual Markdown Editor can also make it easier to insert citations: https://rstudio.github.io/visual-markdown-editing/#/citations References "],["parts.html", "Chapter 11 Parts", " Chapter 11 Parts You can add parts to organize one or more book chapters together. Parts can be inserted at the top of an .Rmd file, before the first-level chapter heading in that same file. Add a numbered part: # (PART) Act one {-} (followed by # A chapter) Add an unnumbered part: # (PART\\*) Act one {-} (followed by # A chapter) Add an appendix as a special kind of un-numbered part: # (APPENDIX) Other stuff {-} (followed by # A chapter). Chapters in an appendix are prepended with letters instead of numbers. "],["references.html", "References", " References "],["sharing-your-book-1.html", "Chapter 12 Sharing your book 12.1 Publishing 12.2 404 pages 12.3 Metadata for sharing", " Chapter 12 Sharing your book 12.1 Publishing HTML books can be published online, see: https://bookdown.org/yihui/bookdown/publishing.html 12.2 404 pages By default, users will be directed to a 404 page if they try to access a webpage that cannot be found. If you’d like to customize your 404 page instead of using the default, you may add either a _404.Rmd or _404.md file to your project root and use code and/or Markdown syntax. 12.3 Metadata for sharing Bookdown HTML books will provide HTML metadata for social sharing on platforms like Twitter, Facebook, and LinkedIn, using information you provide in the index.Rmd YAML. To setup, set the url for your book and the path to your cover-image file. Your book’s title and description are also used. This gitbook uses the same social sharing data across all chapters in your book- all links shared will look the same. Specify your book’s source repository on GitHub using the edit key under the configuration options in the _output.yml file, which allows users to suggest an edit by linking to a chapter’s source file. Read more about the features of this output format here: https://pkgs.rstudio.com/bookdown/reference/gitbook.html Or use: ?bookdown::gitbook "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
